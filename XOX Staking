// SPDX-License-Identifier: MIT
pragma solidity 0.8.31;

import "@openzeppelin/contracts@5.1.0/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts@5.1.0/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts@5.1.0/access/Ownable2Step.sol";
import "@openzeppelin/contracts@5.1.0/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts@5.1.0/utils/Pausable.sol";

/**
 * @title XOX Staking
 * @notice Staking contract for XOX tokens with four vaults and deterministic rewards.
 *
 * Policies:
 * - Pausing blocks only new staking; withdrawal request, claim, and emergency exit remain available.
 * - Principal-first payout: principal is always paid if the contract balance can cover it; rewards are paid up to the reward reserve.
 * - Reward reserve is computed as: max(balanceOf(this) - totalStaked, 0).
 *
 * Token handling:
 * - Staked amount is recorded as the actual received amount to defensively support fee-on-transfer behavior.
 */
contract XOX_STAKING is Ownable2Step, ReentrancyGuard, Pausable {
    using SafeERC20 for IERC20;

    // =============================================================
    //                           CONSTANTS
    // =============================================================

    IERC20 public immutable stakingToken;

    uint256 private constant PRECISION_DIVISOR = 10_000; // 100.00%
    uint256 private constant SECONDS_IN_YEAR   = 365 days;

    uint40 private constant DELAY_STANDARD = uint40(24 hours);
    uint40 private constant DELAY_EARLY    = uint40(72 hours);

    uint256 private constant MIN_DEPOSIT = 5_000 * 1e18;
    uint256 private constant MAX_DEPOSIT = 5_000_000 * 1e18;

    // APY in basis points (10_000 = 100%)
    uint16 private constant APY_BASIC = 300;   // 3.00%
    uint16 private constant APY_90D   = 500;   // 5.00%
    uint16 private constant APY_180D  = 800;   // 8.00%
    uint16 private constant APY_365D  = 1300;  // 13.00%

    uint40 private constant LOCKUP_BASIC = 0;
    uint40 private constant LOCKUP_90D   = uint40(90 days);
    uint40 private constant LOCKUP_180D  = uint40(180 days);
    uint40 private constant LOCKUP_365D  = uint40(365 days);

    uint256 private constant VAULT_COUNT = 4;

    uint8 private constant FLAG_EARLY = 1;

    // =============================================================
    //                          CUSTOM ERRORS
    // =============================================================

    error InvalidTokenAddress();
    error InvalidVaultId();
    error VaultNotActive();
    error AmountZero();
    error AmountBelowMin(uint256 minRequired);
    error AmountExceedsMax(uint256 maxAllowed);
    error AlreadyStaked();
    error NoActiveStake();
    error RequestAlreadySubmitted();
    error RequestNotSubmitted();
    error WaitPeriodNotOver(uint256 claimableAt);
    error CannotWithdrawStakingToken();
    error InsufficientContractBalance();

    // =============================================================
    //                       DATA STRUCTURES
    // =============================================================

    struct Vault {
        uint16 apy;      // annual yield in bps
        uint40 lockup;   // lockup duration in seconds
        bool   active;   // whether new stakes are allowed
    }

    /**
     * @dev Packed into a single storage slot.
     * - amount: uint128
     * - start:  uint40
     * - stop:   uint40
     * - unlock: uint40
     * - flags:  uint8
     */
    struct StakePacked {
        uint128 amount;
        uint40  start;
        uint40  stop;
        uint40  unlock;
        uint8   flags;
    }

    // =============================================================
    //                            STORAGE
    // =============================================================

    Vault[VAULT_COUNT] public vaults;

    mapping(address => mapping(uint256 => StakePacked)) private _stakes;

    // Total staked principal tracked by the contract.
    uint256 public totalStaked;

    // =============================================================
    //                            EVENTS
    // =============================================================

    event Staked(address indexed user, uint256 indexed vaultId, uint256 amount);
    event WithdrawalRequested(address indexed user, uint256 indexed vaultId, uint256 unlockTime, bool isEarly);
    event Claimed(address indexed user, uint256 indexed vaultId, uint256 principal, uint256 rewardsPaid);
    event RewardShortfall(address indexed user, uint256 indexed vaultId, uint256 rewardsOwed, uint256 rewardsPaid);
    event EmergencyWithdrawn(address indexed user, uint256 indexed vaultId, uint256 principal);
    event RewardDeposited(address indexed depositor, uint256 amount);
    event VaultStatusUpdated(uint256 indexed vaultId, bool isActive);

    // =============================================================
    //                          CONSTRUCTOR
    // =============================================================

    constructor(address stakingToken_) Ownable(msg.sender) {
        if (stakingToken_ == address(0)) revert InvalidTokenAddress();
        stakingToken = IERC20(stakingToken_);

        vaults[0] = Vault({ apy: APY_BASIC, lockup: LOCKUP_BASIC, active: true });
        vaults[1] = Vault({ apy: APY_90D,   lockup: LOCKUP_90D,   active: true });
        vaults[2] = Vault({ apy: APY_180D,  lockup: LOCKUP_180D,  active: true });
        vaults[3] = Vault({ apy: APY_365D,  lockup: LOCKUP_365D,  active: true });
    }

    // =============================================================
    //                        USER FUNCTIONS
    // =============================================================

    /**
     * @notice Stake into a vault. One active stake per user per vault.
     * @dev Pausing blocks only this function.
     */
    function stake(uint256 vaultId, uint256 amount) external nonReentrant whenNotPaused {
        if (vaultId >= VAULT_COUNT) revert InvalidVaultId();

        Vault memory v = vaults[vaultId];
        if (!v.active) revert VaultNotActive();

        if (amount == 0) revert AmountZero();
        if (amount < MIN_DEPOSIT) revert AmountBelowMin(MIN_DEPOSIT);
        if (amount > MAX_DEPOSIT) revert AmountExceedsMax(MAX_DEPOSIT);

        StakePacked storage s = _stakes[msg.sender][vaultId];
        if (s.amount != 0) revert AlreadyStaked();

        uint256 balBefore = stakingToken.balanceOf(address(this));
        stakingToken.safeTransferFrom(msg.sender, address(this), amount);
        uint256 received = stakingToken.balanceOf(address(this)) - balBefore;

        if (received == 0) revert AmountZero();
        if (received < MIN_DEPOSIT) revert AmountBelowMin(MIN_DEPOSIT);
        if (received > MAX_DEPOSIT) revert AmountExceedsMax(MAX_DEPOSIT);
        if (received > type(uint128).max) revert AmountExceedsMax(MAX_DEPOSIT);

        uint40 nowTs = uint40(block.timestamp);

        s.amount = uint128(received);
        s.start  = nowTs;
        s.stop   = 0;
        s.unlock = 0;
        s.flags  = 0;

        totalStaked += received;

        emit Staked(msg.sender, vaultId, received);
    }

    /**
     * @notice Request withdrawal; reward accrual stops at request time.
     */
    function requestWithdrawal(uint256 vaultId) external nonReentrant {
        if (vaultId >= VAULT_COUNT) revert InvalidVaultId();

        StakePacked storage s = _stakes[msg.sender][vaultId];
        uint256 principal = uint256(s.amount);
        if (principal == 0) revert NoActiveStake();
        if (s.unlock != 0) revert RequestAlreadySubmitted();

        Vault memory v = vaults[vaultId];
        uint40 nowTs = uint40(block.timestamp);

        bool isEarly;
        uint40 delay;

        if (v.lockup != 0 && nowTs < s.start + v.lockup) {
            isEarly = true;
            delay = DELAY_EARLY;
            s.flags = s.flags | FLAG_EARLY;
        } else {
            isEarly = false;
            delay = DELAY_STANDARD;
        }

        s.stop   = nowTs;
        s.unlock = nowTs + delay;

        emit WithdrawalRequested(msg.sender, vaultId, uint256(s.unlock), isEarly);
    }

    /**
     * @notice Claim principal plus rewards (rewards may be partial/zero if reserve is insufficient).
     */
    function claimWithdrawal(uint256 vaultId) external nonReentrant {
        if (vaultId >= VAULT_COUNT) revert InvalidVaultId();

        StakePacked storage s = _stakes[msg.sender][vaultId];
        uint256 unlockTime = uint256(s.unlock);
        if (unlockTime == 0) revert RequestNotSubmitted();
        if (block.timestamp < unlockTime) revert WaitPeriodNotOver(unlockTime);

        uint256 principal = uint256(s.amount);
        uint256 timeServed = uint256(s.stop) - uint256(s.start);

        uint16 apy = _appliedApy(vaultId, (s.flags & FLAG_EARLY) != 0, timeServed);
        uint256 rewardsOwed = (principal * uint256(apy) * timeServed) / (PRECISION_DIVISOR * SECONDS_IN_YEAR);

        uint256 contractBal = stakingToken.balanceOf(address(this));
        if (contractBal < principal) revert InsufficientContractBalance();

        uint256 stakedTotal = totalStaked;

        uint256 rewardReserve = 0;
        if (contractBal > stakedTotal) rewardReserve = contractBal - stakedTotal;

        uint256 rewardsPaid = rewardsOwed;
        if (rewardsPaid > rewardReserve) {
            rewardsPaid = rewardReserve;
            emit RewardShortfall(msg.sender, vaultId, rewardsOwed, rewardsPaid);
        }

        totalStaked = stakedTotal - principal;
        delete _stakes[msg.sender][vaultId];

        stakingToken.safeTransfer(msg.sender, principal + rewardsPaid);

        emit Claimed(msg.sender, vaultId, principal, rewardsPaid);
    }

    /**
     * @notice Emergency exit: withdraw principal immediately and forfeit rewards.
     */
    function emergencyWithdraw(uint256 vaultId) external nonReentrant {
        if (vaultId >= VAULT_COUNT) revert InvalidVaultId();

        StakePacked storage s = _stakes[msg.sender][vaultId];
        uint256 principal = uint256(s.amount);
        if (principal == 0) revert NoActiveStake();

        uint256 contractBal = stakingToken.balanceOf(address(this));
        if (contractBal < principal) revert InsufficientContractBalance();

        totalStaked -= principal;
        delete _stakes[msg.sender][vaultId];

        stakingToken.safeTransfer(msg.sender, principal);

        emit EmergencyWithdrawn(msg.sender, vaultId, principal);
    }

    // =============================================================
    //                       ADMIN FUNCTIONS
    // =============================================================

    function depositReward(uint256 amount) external onlyOwner nonReentrant {
        if (amount == 0) revert AmountZero();
        stakingToken.safeTransferFrom(msg.sender, address(this), amount);
        emit RewardDeposited(msg.sender, amount);
    }

    function recoverForeignToken(address tokenAddress, uint256 amount) external onlyOwner {
        if (tokenAddress == address(stakingToken)) revert CannotWithdrawStakingToken();
        IERC20(tokenAddress).safeTransfer(owner(), amount);
    }

    function setVaultStatus(uint256 vaultId, bool isActive) external onlyOwner {
        if (vaultId >= VAULT_COUNT) revert InvalidVaultId();
        vaults[vaultId].active = isActive;
        emit VaultStatusUpdated(vaultId, isActive);
    }

    function pause() external onlyOwner { _pause(); }
    function unpause() external onlyOwner { _unpause(); }

    // =============================================================
    //                      VIEW FUNCTIONS
    // =============================================================

    function getStakeInfo(address user, uint256 vaultId)
        external
        view
        returns (
            uint256 amount,
            uint256 startTime,
            uint256 rewardsStopTimestamp,
            uint256 unlockTime,
            bool isEarlyWithdrawal
        )
    {
        if (vaultId >= VAULT_COUNT) revert InvalidVaultId();
        StakePacked memory s = _stakes[user][vaultId];

        amount = uint256(s.amount);
        startTime = uint256(s.start);
        rewardsStopTimestamp = uint256(s.stop);
        unlockTime = uint256(s.unlock);
        isEarlyWithdrawal = (s.flags & FLAG_EARLY) != 0;
    }

    function getRewardReserve() external view returns (uint256) {
        uint256 bal = stakingToken.balanceOf(address(this));
        uint256 stakedTotal = totalStaked;
        if (bal <= stakedTotal) return 0;
        return bal - stakedTotal;
    }

    function getDepositBounds() external pure returns (uint256 minDeposit, uint256 maxDeposit) {
        return (MIN_DEPOSIT, MAX_DEPOSIT);
    }

    // =============================================================
    //                        INTERNAL LOGIC
    // =============================================================

    function _appliedApy(uint256 vaultId, bool isEarly, uint256 timeServed) internal view returns (uint16) {
        if (!isEarly) {
            return vaults[vaultId].apy;
        }

        if (timeServed >= uint256(LOCKUP_180D)) return APY_180D;
        if (timeServed >= uint256(LOCKUP_90D))  return APY_90D;
        return APY_BASIC;
    }
}
