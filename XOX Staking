// SPDX-License-Identifier: MIT
pragma solidity 0.8.31;

import "@openzeppelin/contracts@5.1.0/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts@5.1.0/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts@5.1.0/access/Ownable2Step.sol";
import "@openzeppelin/contracts@5.1.0/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts@5.1.0/utils/Pausable.sol";

/**
 * @title XOX Staking — Fixed-Term Vault Staking with Delayed Withdrawal and Reserve-Limited Rewards
 * @notice Staking contract with four vaults, withdrawal request delays, and reserve-bounded reward payouts.
 *
 * Design overview:
 * - Four vaults: Basic(0d), 90d, 180d, 365d; one active stake per user per vault.
 * - Rewards accumulate until requestWithdrawal() sets the stop timestamp.
 * - For 90/180/365 vaults, when a withdrawal is requested after maturity, rewards stop at maturity
 *   (no extra rewards for late requests).
 * - Withdrawal is two-step:
 *   requestWithdrawal() → waiting period → claimWithdrawal()
 * - Early requests apply a longer delay and a tiered APY downgrade based on time served.
 * - Reward funding model:
 *   - Principal is tracked via totalStaked.
 *   - rewardReserve = max(balanceOf(this) - totalStaked, 0).
 *   - Rewards are paid up to the reserve; any shortfall results in partial reward payment without debt tracking.
 * - Token behavior:
 *   - Stake and reward deposits require received == amount to reject fee-on-transfer or rebasing behaviors.
 *
 * Security model:
 * - Ownership uses Ownable2Step.
 * - Pausing blocks new stakes only; withdrawals remain available.
 * - Emergency withdrawal cannot bypass a pending withdrawal request.
 * - Reentrancy protection is applied to all state-changing external token transfers.
 */
contract XOX_STAKING is Ownable2Step, ReentrancyGuard, Pausable {
    using SafeERC20 for IERC20;

    // =============================================================
    //                           CONSTANTS
    // =============================================================

    /// @notice ERC20 token accepted for staking and rewards.
    IERC20 public immutable stakingToken;

    uint256 private constant PRECISION_DIVISOR = 10_000; // 100.00%
    uint256 private constant SECONDS_IN_YEAR   = 365 days;

    /// @dev Withdrawal request delays.
    uint40 private constant DELAY_STANDARD = uint40(24 hours);
    uint40 private constant DELAY_EARLY    = uint40(72 hours);

    /// @dev Per-stake bounds (18 decimals assumed).
    uint256 private constant MIN_DEPOSIT = 5_000 * 1e18;
    uint256 private constant MAX_DEPOSIT = 5_000_000 * 1e18;

    /// @dev APY in basis points (10_000 = 100%).
    uint16 private constant APY_BASIC = 300;   // 3.00%
    uint16 private constant APY_90D   = 500;   // 5.00%
    uint16 private constant APY_180D  = 800;   // 8.00%
    uint16 private constant APY_365D  = 1300;  // 13.00%

    /// @dev Lockup durations.
    uint40 private constant LOCKUP_BASIC = 0;
    uint40 private constant LOCKUP_90D   = uint40(90 days);
    uint40 private constant LOCKUP_180D  = uint40(180 days);
    uint40 private constant LOCKUP_365D  = uint40(365 days);

    uint256 private constant VAULT_COUNT = 4;

    /// @dev Flags.
    uint8 private constant FLAG_EARLY = 1;

    // =============================================================
    //                             ERRORS
    // =============================================================

    error InvalidTokenAddress();
    error InvalidVaultId();
    error VaultNotActive();
    error AmountZero();
    error AmountBelowMin(uint256 minRequired);
    error AmountExceedsMax(uint256 maxAllowed);
    error AlreadyStaked();
    error NoActiveStake();
    error RequestAlreadySubmitted();
    error RequestNotSubmitted();
    error WaitPeriodNotOver(uint256 claimableAt);
    error CannotWithdrawStakingToken();
    error InsufficientContractBalance();
    error UnsupportedTokenBehavior();
    error WithdrawalRequestPending();
    error TimestampOverflow();

    // =============================================================
    //                          DATA TYPES
    // =============================================================

    struct Vault {
        uint16 apy;      // annual yield in bps
        uint40 lockup;   // lockup duration in seconds
        bool   active;   // whether new stakes are allowed
    }

    /**
     * @dev Packed stake state:
     * - amount: staked principal (uint128)
     * - start:  stake timestamp (uint40)
     * - stop:   rewards stop timestamp (uint40)
     * - unlock: claim-eligible timestamp (uint40)
     * - flags:  bit flags (uint8)
     */
    struct StakePacked {
        uint128 amount;
        uint40  start;
        uint40  stop;
        uint40  unlock;
        uint8   flags;
    }

    // =============================================================
    //                            STORAGE
    // =============================================================

    /// @notice Vault configuration array (fixed size).
    Vault[VAULT_COUNT] public vaults;

    /// @dev One stake per user per vault.
    mapping(address => mapping(uint256 => StakePacked)) private _stakes;

    /// @notice Total tracked principal across all users.
    uint256 public totalStaked;

    // =============================================================
    //                            EVENTS
    // =============================================================

    event Staked(address indexed user, uint256 indexed vaultId, uint256 amount);
    event WithdrawalRequested(address indexed user, uint256 indexed vaultId, uint256 unlockTime, bool isEarly);
    event Claimed(address indexed user, uint256 indexed vaultId, uint256 principal, uint256 rewardsPaid);
    event RewardShortfall(address indexed user, uint256 indexed vaultId, uint256 rewardsOwed, uint256 rewardsPaid);
    event EmergencyWithdrawn(address indexed user, uint256 indexed vaultId, uint256 principal);
    event RewardDeposited(address indexed depositor, uint256 amount);
    event VaultStatusUpdated(uint256 indexed vaultId, bool isActive);

    // =============================================================
    //                          CONSTRUCTOR
    // =============================================================

    /**
     * @dev Initializes the staking token and the four vault configurations.
     */
    constructor(address stakingToken_) Ownable(msg.sender) {
        if (stakingToken_ == address(0)) revert InvalidTokenAddress();
        stakingToken = IERC20(stakingToken_);

        vaults[0] = Vault({ apy: APY_BASIC, lockup: LOCKUP_BASIC, active: true });
        vaults[1] = Vault({ apy: APY_90D,   lockup: LOCKUP_90D,   active: true });
        vaults[2] = Vault({ apy: APY_180D,  lockup: LOCKUP_180D,  active: true });
        vaults[3] = Vault({ apy: APY_365D,  lockup: LOCKUP_365D,  active: true });
    }

    // =============================================================
    //                       CORE USER FLOWS
    // =============================================================

    /**
     * @notice Stakes tokens into a vault.
     * @dev Pausing blocks only this function.
     *
     * Requirements:
     * - Contract must not be paused.
     * - vaultId must be valid and the vault must be active.
     * - amount must be within [MIN_DEPOSIT, MAX_DEPOSIT].
     * - Caller must not already have an active stake in the same vault.
     * - Token transfer must satisfy received == amount.
     */
    function stake(uint256 vaultId, uint256 amount) external nonReentrant whenNotPaused {
        if (vaultId >= VAULT_COUNT) revert InvalidVaultId();

        Vault storage v = vaults[vaultId];
        if (!v.active) revert VaultNotActive();

        if (amount == 0) revert AmountZero();
        if (amount < MIN_DEPOSIT) revert AmountBelowMin(MIN_DEPOSIT);
        if (amount > MAX_DEPOSIT) revert AmountExceedsMax(MAX_DEPOSIT);

        StakePacked storage s = _stakes[msg.sender][vaultId];
        if (s.amount != 0) revert AlreadyStaked();

        uint256 balBefore = stakingToken.balanceOf(address(this));
        stakingToken.safeTransferFrom(msg.sender, address(this), amount);
        uint256 received = stakingToken.balanceOf(address(this)) - balBefore;

        if (received != amount) revert UnsupportedTokenBehavior();

        uint40 nowTs = uint40(block.timestamp);

        // amount is capped by MAX_DEPOSIT, guaranteed to fit into uint128
        s.amount = uint128(amount);
        s.start  = nowTs;
        s.stop   = 0;
        s.unlock = 0;
        s.flags  = 0;

        unchecked { totalStaked += amount; }

        emit Staked(msg.sender, vaultId, amount);
    }

    /**
     * @notice Requests withdrawal; sets the rewards stop timestamp and unlock time.
     *
     * Maturity rule:
     * - For time-locked vaults, if requested after maturity, rewards stop at maturity.
     * - If requested before maturity, rewards stop at request time (early).
     *
     * Delay rule:
     * - Early: 72 hours
     * - Normal: 24 hours
     *
     * Requirements:
     * - Caller must have an active stake in the vault.
     * - A request must not already exist for this stake.
     */
    function requestWithdrawal(uint256 vaultId) external nonReentrant {
        if (vaultId >= VAULT_COUNT) revert InvalidVaultId();

        StakePacked storage s = _stakes[msg.sender][vaultId];
        uint256 principal = uint256(s.amount);
        if (principal == 0) revert NoActiveStake();
        if (s.unlock != 0) revert RequestAlreadySubmitted();

        Vault storage v = vaults[vaultId];
        uint40 lockup = v.lockup;

        uint40 nowTs = uint40(block.timestamp);

        bool isEarly;
        uint40 delay;
        uint40 stopTs;

        if (lockup != 0) {
            uint256 maturity256 = uint256(s.start) + uint256(lockup);
            if (maturity256 > type(uint40).max) revert TimestampOverflow();
            uint40 maturity = uint40(maturity256);

            if (nowTs < maturity) {
                isEarly = true;
                delay = DELAY_EARLY;
                s.flags = s.flags | FLAG_EARLY;
                stopTs = nowTs;
            } else {
                isEarly = false;
                delay = DELAY_STANDARD;
                stopTs = maturity;
            }
        } else {
            isEarly = false;
            delay = DELAY_STANDARD;
            stopTs = nowTs;
        }

        s.stop = stopTs;
        s.unlock = nowTs + delay;

        emit WithdrawalRequested(msg.sender, vaultId, uint256(s.unlock), isEarly);
    }

    /**
     * @notice Claims principal plus rewards after the unlock time.
     *
     * Reward funding rule:
     * - Rewards are paid up to the reward reserve.
     * - Any shortfall results in partial reward payment without debt tracking.
     *
     * Requirements:
     * - A withdrawal request must exist for the stake.
     * - The current timestamp must be at least unlockTime.
     * - Contract balance must cover the principal.
     */
    function claimWithdrawal(uint256 vaultId) external nonReentrant {
        if (vaultId >= VAULT_COUNT) revert InvalidVaultId();

        StakePacked storage s = _stakes[msg.sender][vaultId];
        uint256 unlockTime = uint256(s.unlock);
        if (unlockTime == 0) revert RequestNotSubmitted();
        if (block.timestamp < unlockTime) revert WaitPeriodNotOver(unlockTime);

        uint40 start_ = s.start;
        uint40 stop_  = s.stop;
        if (start_ == 0 || stop_ == 0 || stop_ < start_) revert RequestNotSubmitted();

        uint256 principal = uint256(s.amount);
        uint256 timeServed = uint256(stop_) - uint256(start_);

        uint16 apy = _appliedApy(vaultId, (s.flags & FLAG_EARLY) != 0, timeServed);
        uint256 rewardsOwed = (principal * uint256(apy) * timeServed) / (PRECISION_DIVISOR * SECONDS_IN_YEAR);

        uint256 contractBal = stakingToken.balanceOf(address(this));
        if (contractBal < principal) revert InsufficientContractBalance();

        uint256 stakedTotal = totalStaked;

        uint256 rewardReserve = 0;
        if (contractBal > stakedTotal) rewardReserve = contractBal - stakedTotal;

        uint256 rewardsPaid = rewardsOwed;
        if (rewardsPaid > rewardReserve) {
            rewardsPaid = rewardReserve;
            emit RewardShortfall(msg.sender, vaultId, rewardsOwed, rewardsPaid);
        }

        unchecked { totalStaked = stakedTotal - principal; }
        delete _stakes[msg.sender][vaultId];

        stakingToken.safeTransfer(msg.sender, principal + rewardsPaid);

        emit Claimed(msg.sender, vaultId, principal, rewardsPaid);
    }

    /**
     * @notice Emergency exit that returns principal immediately and forfeits rewards.
     *
     * Request rule:
     * - Not available if a withdrawal request is pending (no delay bypass).
     *
     * Requirements:
     * - Caller must have an active stake in the vault.
     * - Contract balance must cover the principal.
     */
    function emergencyWithdraw(uint256 vaultId) external nonReentrant {
        if (vaultId >= VAULT_COUNT) revert InvalidVaultId();

        StakePacked storage s = _stakes[msg.sender][vaultId];
        uint256 principal = uint256(s.amount);
        if (principal == 0) revert NoActiveStake();

        if (s.unlock != 0) revert WithdrawalRequestPending();

        uint256 contractBal = stakingToken.balanceOf(address(this));
        if (contractBal < principal) revert InsufficientContractBalance();

        unchecked { totalStaked -= principal; }
        delete _stakes[msg.sender][vaultId];

        stakingToken.safeTransfer(msg.sender, principal);

        emit EmergencyWithdrawn(msg.sender, vaultId, principal);
    }

    // =============================================================
    //                      ADMIN & SECURITY
    // =============================================================

    /**
     * @notice Deposits reward tokens into the contract.
     *
     * Requirements:
     * - Caller must be the owner.
     * - amount must be greater than zero.
     * - Token transfer must satisfy received == amount.
     */
    function depositReward(uint256 amount) external onlyOwner {
        if (amount == 0) revert AmountZero();

        uint256 balBefore = stakingToken.balanceOf(address(this));
        stakingToken.safeTransferFrom(msg.sender, address(this), amount);
        uint256 received = stakingToken.balanceOf(address(this)) - balBefore;

        if (received != amount) revert UnsupportedTokenBehavior();

        emit RewardDeposited(msg.sender, amount);
    }

    /**
     * @notice Recovers non-staking ERC20 tokens accidentally sent to this contract.
     *
     * Requirements:
     * - Caller must be the owner.
     * - tokenAddress must not be the staking token.
     */
    function recoverForeignToken(address tokenAddress, uint256 amount) external onlyOwner {
        if (tokenAddress == address(stakingToken)) revert CannotWithdrawStakingToken();
        IERC20(tokenAddress).safeTransfer(owner(), amount);
    }

    /**
     * @notice Enables or disables new stakes for a vault.
     *
     * Note:
     * - This affects only stake(); existing positions may still request and claim withdrawals.
     *
     * Requirements:
     * - Caller must be the owner.
     * - vaultId must be valid.
     */
    function setVaultStatus(uint256 vaultId, bool isActive) external onlyOwner {
        if (vaultId >= VAULT_COUNT) revert InvalidVaultId();
        vaults[vaultId].active = isActive;
        emit VaultStatusUpdated(vaultId, isActive);
    }

    /**
     * @notice Pauses new staking.
     */
    function pause() external onlyOwner { _pause(); }

    /**
     * @notice Unpauses new staking.
     */
    function unpause() external onlyOwner { _unpause(); }

    // =============================================================
    //                      VIEW FUNCTIONS
    // =============================================================

    /**
     * @notice Returns stake details for a user and vault.
     * @param user Stake owner address.
     * @param vaultId Vault id.
     * @return amount Staked principal.
     * @return startTime Stake start timestamp.
     * @return rewardsStopTimestamp Rewards stop timestamp (set by requestWithdrawal()).
     * @return unlockTime Claim-eligible timestamp.
     * @return isEarlyWithdrawal True if the position was marked early at request time.
     */
    function getStakeInfo(address user, uint256 vaultId)
        external
        view
        returns (
            uint256 amount,
            uint256 startTime,
            uint256 rewardsStopTimestamp,
            uint256 unlockTime,
            bool isEarlyWithdrawal
        )
    {
        if (vaultId >= VAULT_COUNT) revert InvalidVaultId();
        StakePacked memory s = _stakes[user][vaultId];

        amount = uint256(s.amount);
        startTime = uint256(s.start);
        rewardsStopTimestamp = uint256(s.stop);
        unlockTime = uint256(s.unlock);
        isEarlyWithdrawal = (s.flags & FLAG_EARLY) != 0;
    }

    /**
     * @notice Returns the current reward reserve amount.
     * @dev rewardReserve = max(balanceOf(this) - totalStaked, 0).
     */
    function getRewardReserve() external view returns (uint256) {
        uint256 bal = stakingToken.balanceOf(address(this));
        uint256 stakedTotal = totalStaked;
        if (bal <= stakedTotal) return 0;
        return bal - stakedTotal;
    }

    /**
     * @notice Returns the min/max deposit bounds.
     */
    function getDepositBounds() external pure returns (uint256 minDeposit, uint256 maxDeposit) {
        return (MIN_DEPOSIT, MAX_DEPOSIT);
    }

    // =============================================================
    //                        INTERNAL LOGIC
    // =============================================================

    /**
     * @dev Returns the applied APY for early withdrawal, based on time served.
     * If not early, returns the vault APY.
     */
    function _appliedApy(uint256 vaultId, bool isEarly, uint256 timeServed) internal view returns (uint16) {
        if (!isEarly) return vaults[vaultId].apy;

        if (timeServed >= uint256(LOCKUP_180D)) return APY_180D;
        if (timeServed >= uint256(LOCKUP_90D))  return APY_90D;
        return APY_BASIC;
    }
}
