// SPDX-License-Identifier: MIT
pragma solidity 0.8.31;

import "@openzeppelin/contracts@5.1.0/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts@5.1.0/token/ERC20/extensions/ERC20Permit.sol";
import "@openzeppelin/contracts@5.1.0/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts@5.1.0/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts@5.1.0/access/Ownable2Step.sol";
import "@openzeppelin/contracts@5.1.0/utils/Pausable.sol";
import "@openzeppelin/contracts@5.1.0/utils/ReentrancyGuard.sol";

/**
 * @title XOX Token â€” Fixed Supply ERC20 with Permit, Airdrops, and Emergency Controls
 * @notice XOX is a fixed-supply ERC20 token with EIP-2612 Permit, owner-operated airdrops, and emergency safety controls.
 *
 * Design overview:
 * - Fixed supply minted once at deployment.
 * - Permit (EIP-2612) enables gasless approvals via signatures.
 * - Batch airdrops support per-recipient cooldowns and batch sizing constraints.
 * - Airdrop recipient lists must not contain duplicates (operator-safety invariant).
 * - Transfers are pausable via a centralized transfer gate that covers all token movements.
 * - Emergency recovery functions exist for assets accidentally sent to the contract.
 *
 * Security model:
 * - Ownership uses Ownable2Step to reduce accidental transfers.
 * - Pausing is enforced centrally in the transfer hook to cover transfers, mint, and burn.
 * - Reentrancy protection is applied to admin flows that perform external calls.
 */
contract XOX is ERC20, ERC20Permit, Ownable2Step, Pausable, ReentrancyGuard {
    using SafeERC20 for IERC20;

    // =============================================================
    //                           CONSTANTS
    // =============================================================

    /// @dev Total fixed supply: 1,000,000,000 XOX (18 decimals).
    uint256 private constant INITIAL_SUPPLY = 1_000_000_000 * 10**18;

    /// @dev Maximum number of recipients permitted in one airdrop call.
    uint256 private constant MAX_AIRDROP_BATCH_SIZE = 100;

    /// @dev Per-recipient airdrop cooldown duration.
    uint256 private constant AIRDROP_COOLDOWN = 24 hours;

    // =============================================================
    //                             ERRORS
    // =============================================================

    error LenMismatch();
    error BatchSizeTooLarge();
    error InsufficientBalance();
    error InvalidRecipient();
    error RecipientInCooldown();
    error ZeroAmount();
    error ZeroAddress();
    error NoTokensToWithdraw();
    error NoBNBToWithdraw();
    error BNBTransferFailed();

    /// @dev Revert when the recipients list contains a duplicate non-zero address.
    error DuplicateRecipient(address recipient);

    // =============================================================
    //                            STORAGE
    // =============================================================

    /// @dev Timestamp after which an address may receive the next airdrop.
    mapping(address => uint256) private nextAirdropAvailable;

    /**
     * @dev Per-call duplicate detection without clearing storage:
     * - airdropBatchNonce increments each call
     * - seenInAirdropBatch[addr] == currentNonce implies addr already appeared in this call
     */
    uint256 private airdropBatchNonce;
    mapping(address => uint256) private seenInAirdropBatch;

    // =============================================================
    //                            EVENTS
    // =============================================================

    event TokensBurned(address indexed burner, uint256 amount, uint256 currentTotalSupply);
    event Airdrop(address indexed recipient, uint256 amount, uint256 nextUnlockTime);

    /**
     * @dev Emitted when an entry is ignored during non-atomic airdrops.
     * reasonCode values:
     *  1 = zero address
     *  2 = zero amount
     *  3 = cooldown active
     */
    event AirdropSkipped(address indexed recipient, uint256 amount, uint8 reasonCode);

    event EmergencyTokensWithdrawn(address indexed owner, address indexed token, uint256 amount);
    event EmergencyBNBWithdrawn(address indexed owner, uint256 amount);

    // Compact reason codes for AirdropSkipped
    uint8 private constant SKIP_ZERO_ADDRESS = 1;
    uint8 private constant SKIP_ZERO_AMOUNT  = 2;
    uint8 private constant SKIP_COOLDOWN     = 3;

    // =============================================================
    //                          CONSTRUCTOR
    // =============================================================

    /**
     * @dev Mints the full fixed supply to the deployer and initializes Permit.
     */
    constructor()
        ERC20("XOX", "XOX")
        ERC20Permit("XOX")
        Ownable(msg.sender)
    {
        _mint(msg.sender, INITIAL_SUPPLY);
    }

    // =============================================================
    //                       CORE FUNCTIONS
    // =============================================================

    /**
     * @notice Burns tokens from the owner's balance, reducing total supply.
     * @param amount Amount of tokens to burn.
     *
     * Requirements:
     * - Caller must be the owner.
     * - Contract must not be paused.
     * - amount must be greater than zero.
     * - Owner must have at least amount tokens.
     */
    function burn(uint256 amount) external onlyOwner whenNotPaused {
        if (amount == 0) revert ZeroAmount();
        if (balanceOf(msg.sender) < amount) revert InsufficientBalance();

        _burn(msg.sender, amount);
        emit TokensBurned(msg.sender, amount, totalSupply());
    }

    /**
     * @notice Executes a batch airdrop with strict atomicity.
     * @dev Any invalid entry causes a full revert.
     *
     * @param recipients Recipient addresses.
     * @param amounts Token amounts per recipient.
     *
     * Requirements:
     * - Caller must be the owner.
     * - Contract must not be paused.
     * - Arrays must have equal length.
     * - Batch size must not exceed MAX_AIRDROP_BATCH_SIZE.
     * - Owner must have sufficient balance for the entire validated batch sum.
     * - Each entry must satisfy: recipient != 0, amount > 0, cooldown passed.
     * - Recipients must be unique within the batch (non-zero addresses).
     */
    function bulkAirdrop(
        address[] calldata recipients,
        uint256[] calldata amounts
    ) external onlyOwner {
        uint256 len = recipients.length;
        if (len != amounts.length) revert LenMismatch();
        if (len > MAX_AIRDROP_BATCH_SIZE) revert BatchSizeTooLarge();

        address sender = msg.sender;
        uint256 nowTs = block.timestamp;

        uint256 batchId = ++airdropBatchNonce;

        uint256 totalAmount;
        for (uint256 i = 0; i < len; ) {
            address recipient = recipients[i];
            uint256 amount = amounts[i];

            if (recipient == address(0)) revert InvalidRecipient();
            if (amount == 0) revert ZeroAmount();

            if (seenInAirdropBatch[recipient] == batchId) revert DuplicateRecipient(recipient);
            seenInAirdropBatch[recipient] = batchId;

            if (nowTs < nextAirdropAvailable[recipient]) revert RecipientInCooldown();

            totalAmount += amount;
            unchecked { ++i; }
        }

        if (balanceOf(sender) < totalAmount) revert InsufficientBalance();

        uint256 nextUnlock = nowTs + AIRDROP_COOLDOWN;

        for (uint256 i = 0; i < len; ) {
            address recipient = recipients[i];
            uint256 amount = amounts[i];

            _transfer(sender, recipient, amount);

            nextAirdropAvailable[recipient] = nextUnlock;
            emit Airdrop(recipient, amount, nextUnlock);

            unchecked { ++i; }
        }
    }

    /**
     * @notice Executes a batch airdrop that tolerates invalid or ineligible entries.
     * @dev Entries with a zero address, zero amount, or active cooldown are ignored.
     *
     * Funding rule:
     * - The owner must have enough balance to cover the sum of eligible entries; otherwise the call reverts.
     *
     * Duplicate rule:
     * - Duplicate non-zero recipients are treated as an operator error and cause a full revert.
     *
     * @param recipients Recipient addresses.
     * @param amounts Token amounts per recipient.
     *
     * Requirements:
     * - Caller must be the owner.
     * - Arrays must have equal length.
     * - Batch size must not exceed MAX_AIRDROP_BATCH_SIZE.
     * - Recipients must be unique within the batch (non-zero addresses).
     * - Contract must not be paused (enforced in the transfer hook).
     */
    function bulkAirdropNonAtomic(
        address[] calldata recipients,
        uint256[] calldata amounts
    ) external onlyOwner {
        uint256 len = recipients.length;
        if (len != amounts.length) revert LenMismatch();
        if (len > MAX_AIRDROP_BATCH_SIZE) revert BatchSizeTooLarge();

        address sender = msg.sender;
        uint256 nowTs = block.timestamp;

        uint256 batchId = ++airdropBatchNonce;

        uint256 eligibleTotal;
        for (uint256 i = 0; i < len; ) {
            address recipient = recipients[i];
            uint256 amount = amounts[i];

            if (recipient != address(0)) {
                if (seenInAirdropBatch[recipient] == batchId) revert DuplicateRecipient(recipient);
                seenInAirdropBatch[recipient] = batchId;

                if (amount != 0 && nowTs >= nextAirdropAvailable[recipient]) {
                    eligibleTotal += amount;
                }
            }

            unchecked { ++i; }
        }

        if (balanceOf(sender) < eligibleTotal) revert InsufficientBalance();

        uint256 nextUnlock = nowTs + AIRDROP_COOLDOWN;

        for (uint256 i = 0; i < len; ) {
            address recipient = recipients[i];
            uint256 amount = amounts[i];

            // Skip zero-address silently to avoid operational confusion in off-chain monitoring.
            if (recipient == address(0)) {
                unchecked { ++i; }
                continue;
            }

            if (amount == 0) {
                emit AirdropSkipped(recipient, amount, SKIP_ZERO_AMOUNT);
                unchecked { ++i; }
                continue;
            }
            if (nowTs < nextAirdropAvailable[recipient]) {
                emit AirdropSkipped(recipient, amount, SKIP_COOLDOWN);
                unchecked { ++i; }
                continue;
            }

            _transfer(sender, recipient, amount);

            nextAirdropAvailable[recipient] = nextUnlock;
            emit Airdrop(recipient, amount, nextUnlock);

            unchecked { ++i; }
        }
    }

    // =============================================================
    //                      VIEW FUNCTIONS
    // =============================================================

    /**
     * @notice Returns remaining cooldown time for an address.
     * @param account Address to check.
     * @return remainingTime Seconds until the address becomes eligible for the next airdrop (0 if eligible now).
     */
    function getRemainingCooldown(address account) external view returns (uint256 remainingTime) {
        uint256 unlockTime = nextAirdropAvailable[account];
        if (block.timestamp >= unlockTime) return 0;
        return unlockTime - block.timestamp;
    }

    // =============================================================
    //                      ADMIN & SECURITY
    // =============================================================

    /**
     * @notice Pauses token transfers.
     */
    function pause() external onlyOwner {
        _pause();
    }

    /**
     * @notice Unpauses token transfers.
     */
    function unpause() external onlyOwner {
        _unpause();
    }

    /**
     * @notice Recovers ERC20 tokens accidentally sent to this contract.
     * @param tokenAddress Token contract address to recover.
     *
     * Requirements:
     * - Caller must be the owner.
     * - tokenAddress must not be zero.
     * - Contract must hold a positive balance of the token.
     *
     * Reentrancy:
     * - Protected because this function performs external calls to arbitrary token contracts.
     */
    function emergencyWithdrawTokens(address tokenAddress) external onlyOwner nonReentrant {
        if (tokenAddress == address(0)) revert ZeroAddress();

        IERC20 token = IERC20(tokenAddress);
        uint256 balance = token.balanceOf(address(this));
        if (balance == 0) revert NoTokensToWithdraw();

        address o = owner();
        token.safeTransfer(o, balance);

        emit EmergencyTokensWithdrawn(o, tokenAddress, balance);
    }

    /**
     * @notice Recovers native coins (e.g., BNB) that became stuck in this contract.
     * @dev Native coins can be forced into a contract by certain EVM mechanics even if direct transfers are rejected.
     *
     * Reentrancy:
     * - Protected because this function performs an external call with value.
     */
    function withdrawStuckBNB() external onlyOwner nonReentrant {
        uint256 balance = address(this).balance;
        if (balance == 0) revert NoBNBToWithdraw();

        address o = owner();
        (bool success, ) = payable(o).call{value: balance}("");
        if (!success) revert BNBTransferFailed();

        emit EmergencyBNBWithdrawn(o, balance);
    }

    // =============================================================
    //                        OVERRIDES
    // =============================================================

    /**
     * @dev Centralized transfer gate that enforces the paused state across all token movements.
     */
    function _update(address from, address to, uint256 value)
        internal
        override(ERC20)
        whenNotPaused
    {
        super._update(from, to, value);
    }

    // =============================================================
    //                    FALLBACK FUNCTIONS
    // =============================================================

    /**
     * @dev Rejects direct native coin transfers to reduce operational mistakes.
     */
    receive() external payable {
        revert("XOX: Direct BNB transfer not allowed");
    }

    /**
     * @dev Rejects calls to unknown functions and direct native coin transfers.
     */
    fallback() external payable {
        revert("XOX: Direct BNB transfer not allowed");
    }
}
